// -*- C++ -*-
//===-------------------- algorithm_constexpr_par -------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_ALGORITHM_CONSTEXPR_PAR
#define _LIBCPP_ALGORITHM_CONSTEXPR_PAR

#include <__algorithm_support>
#include <__config>
#include <execution>
#include <initializer_list>
#include <type_traits>
#include <cstring>
#include <utility> // needed to provide swap_ranges.
#include <memory>
#include <iterator>
#include <cstddef>
#include <bit>
#include <version>

#include <__debug>

#include "loop_wrapper.h"

using namespace cest::loop_wrapper;

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_PUSH_MACROS
#include <__undef_macros>

_LIBCPP_BEGIN_NAMESPACE_STD

// TODO:
// 5) Perhaps these should all be made consteval, rather than constexpr as we 
//    don't really want these to be used outside of compile time, in every case
//    so far it'll work sequentially but is not guaranteed to be optimal/as 
//    performant as the true runtime sequential implementation
// 6) OK, so, the issue with checking for the execution policy in the compiler
//    as a parameter is that it'll mean that the execution policy cannot be 
//    passed around as a parameter. It'll pick it up and try parallelize where
//    it shouldn't.
//    1) Either we still need to filter by function name or namespace as well
//    2) Come up with some other indicator, like a wrapper function or function 
//       attribute to indicate it's in a constexpr parallel scope
//    3) Some segment of the execution policy that is perhaps switched on inside
//       of the function when we want to use it in a constexpr fashion
//    I am pretty sure the second one is the most apt... while I suppose in 
//    theory you could do the 3rd, it feels like a slightly more hacky solution.
//    currently number 1) is partially implemented it requires it to be in the
//    std:: library namespace and have an execution policy parameter

// TODO: Compiler
// 2) Fix the fact that the APValues actually get changed on the original at the
//    moment, even if they get set back correctly they really shouldn't be 
//    altered in the original until the end incase it creates some sideaffects.
// 3) test removal of:     __IteratorLoopStep(__result, 1); from 
//    set_intersection, there is a solid chance there will be a problem when 
//    everything is trying to write to the same point in the array but this 
//    is likely an issue that needs to be overcoem


// all_of

template <class _ExecutionPolicy, class _InputIterator, class _Predicate>
_LIBCPP_NODISCARD_EXT 
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              bool>
all_of(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, 
      _Predicate __pred)
{
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__first, 1);
    
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            return false;
    return true;
}

// any_of

template <class _ExecutionPolicy, class _InputIterator, class _Predicate>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              bool>
any_of(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, 
       _Predicate __pred)
{
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__first, 1);
    
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return true;
    return false;
}

// none_of

template <class _ExecutionPolicy, class _InputIterator, class _Predicate>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              bool>
none_of(_ExecutionPolicy&& __exec, _InputIterator __first, 
        _InputIterator __last, _Predicate __pred)
{
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__first, 1);
    
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}


// for_each

template <class _ExecutionPolicy, class _ForwardIterator, class _Function>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              void>
for_each(_ExecutionPolicy&& __exec, _ForwardIterator __first, 
         _ForwardIterator __last, _Function __f)
{
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__first, 1);

    for (; __first != __last; ++__first)
        __f(*__first);
}

// find

template <class _ExecutionPolicy, class _InputIterator, class _Tp>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _InputIterator>
find(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, 
     const _Tp& __value_)
{
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__first, 1);

    for (; __first != __last; ++__first)
        if (*__first == __value_)
            break;
    return __first;
}

// find_if

template <class _ExecutionPolicy, class _InputIterator, class _Predicate>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _InputIterator>
find_if(_ExecutionPolicy&& __exec, _InputIterator __first, 
        _InputIterator __last, _Predicate __pred)
{
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__first, 1);
    
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            break;
    return __first;
}

// find_if_not

template<class _ExecutionPolicy, class _InputIterator, class _Predicate>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _InputIterator>
find_if_not(_ExecutionPolicy&& __exec, _InputIterator __first, 
            _InputIterator __last, _Predicate __pred)
{
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__first, 1);
    
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    return __first;
}

// find_first_of

template <class _ExecutionPolicy, class _ForwardIterator1, 
          class _ForwardIterator2, class _BinaryPredicate>
_LIBCPP_CONSTEXPR_AFTER_CXX11
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _ForwardIterator1>
__find_first_of_ce(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, 
                   _ForwardIterator1 __last1, _ForwardIterator2 __first2, 
                   _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    // only parallelize/partition the outer loop
    __BeginEndIteratorPair(__first1, __last1);
    __IteratorLoopStep(__first1, 1);
        
    for (; __first1 != __last1; ++__first1)
        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
            if (__pred(*__first1, *__j))
                return __first1;
    return __last1;
}


template <class _ExecutionPolicy, class _ForwardIterator1, 
          class _ForwardIterator2, class _BinaryPredicate>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _ForwardIterator1>
find_first_of(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, 
              _ForwardIterator1 __last1, _ForwardIterator2 __first2, 
              _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return _VSTD::__find_first_of_ce(__exec, __first1, __last1, __first2, 
                                     __last2, __pred);
}

template <class _ExecutionPolicy, class _ForwardIterator1, 
          class _ForwardIterator2>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _ForwardIterator1>
find_first_of(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, 
              _ForwardIterator1 __last1, _ForwardIterator2 __first2, 
              _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return _VSTD::__find_first_of_ce(__exec, __first1, __last1, __first2, 
                                     __last2, __equal_to<__v1, __v2>());
}

// count

template <class _ExecutionPolicy, class _InputIterator, class _Tp>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                      _ExecutionPolicy, 
                      typename iterator_traits<_InputIterator>::difference_type>
count(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, 
      const _Tp& __value_)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__first, 1);
    __ReduceVariable(__r, ReductionType::Accumulate, OperatorType::PreInc);
    
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            ++__r;
    return __r;
}

// count_if

template <class _ExecutionPolicy, class _InputIterator, class _Predicate>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                      _ExecutionPolicy, 
                      typename iterator_traits<_InputIterator>::difference_type>
count_if(_ExecutionPolicy&& __exec, _InputIterator __first, 
         _InputIterator __last, _Predicate __pred)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
 
     __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__first, 1);
    __ReduceVariable(__r, ReductionType::Accumulate, OperatorType::PreInc);
    
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            ++__r;
    return __r;
}


// mismatch, TODO: Add Mismatch overload added in C++14

template <class _ExecutionPolicy, class _InputIterator1, class _InputIterator2, 
          class _BinaryPredicate>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                         _ExecutionPolicy, 
                                         pair<_InputIterator1, _InputIterator2>>
mismatch(_ExecutionPolicy&& __exec, _InputIterator1 __first1, 
         _InputIterator1 __last1, _InputIterator2 __first2, 
         _BinaryPredicate __pred)
{
    __BeginEndIteratorPair(__first1, __last1);
    __IteratorLoopStep(__first1, 1);
    __IteratorLoopStep(__first2, 1);
    
    for (; __first1 != __last1; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _ExecutionPolicy, class _InputIterator1, class _InputIterator2>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                         _ExecutionPolicy, 
                                         pair<_InputIterator1, _InputIterator2>>
mismatch(_ExecutionPolicy&& __exec, _InputIterator1 __first1, 
         _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return _VSTD::mismatch(__exec, __first1, __last1, __first2, 
                           __equal_to<__v1, __v2>());
}

template <class _ExecutionPolicy, class _InputIterator, class _OutputIterator>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _OutputIterator>
__copy_constexpr(_ExecutionPolicy&& __exec, _InputIterator __first, 
                 _InputIterator __last, _OutputIterator __result)
{
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__first, 1);
    __IteratorLoopStep(__result, 1);
      
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = *__first;
    return __result;
}

template <class _ExecutionPolicy, class _InputIterator, class _OutputIterator>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17_WITH_IS_CONSTANT_EVALUATED
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _OutputIterator>
copy(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, 
     _OutputIterator __result)
{
    return _VSTD::__copy_constexpr(__exec,
        __unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}


// copy_backward
// This doesn't seem to have an execution policy overload but it seems simple to
// implement for us.

template <class _ExecutionPolicy, class _BidirectionalIterator, 
          class _OutputIterator>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy,
                                                              _OutputIterator>
__copy_backward_constexpr(_ExecutionPolicy&& __exec, 
                          _BidirectionalIterator __first, 
                          _BidirectionalIterator __last, 
                          _OutputIterator __result)
{
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__first, 1);
/*    __IteratorLoopStep(__last, 1);*/
    __IteratorLoopStep(__result, 1);
    
    for (; __first != __last;)
        *--__result = *--__last;
/*    while (__first != __last)*/
/*        *--__result = *--__last;*/
    return __result;
}

template <class _ExecutionPolicy, class _BidirectionalIterator, 
          class _OutputIterator>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17_WITH_IS_CONSTANT_EVALUATED
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy,
                                                              _OutputIterator>
__copy_backward(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, 
                _BidirectionalIterator __last, _OutputIterator __result)
{
    return __copy_backward_constexpr(__exec, __first, __last, __result);
}


template <class _ExecutionPolicy, class _BidirectionalIterator1, 
          class _BidirectionalIterator2>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17_WITH_IS_CONSTANT_EVALUATED
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                        _ExecutionPolicy, 
                                                        _BidirectionalIterator2>
copy_backward(_ExecutionPolicy&& __exec, _BidirectionalIterator1 __first, 
              _BidirectionalIterator1 __last, _BidirectionalIterator2 __result)
{
    return _VSTD::__copy_backward_constexpr(__exec, __unwrap_iter(__first),
                                            __unwrap_iter(__last),
                                            __unwrap_iter(__result));
}

// copy_if

template<class _ExecutionPolicy, class _InputIterator, class _OutputIterator, 
         class _Predicate>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _OutputIterator>
copy_if(_ExecutionPolicy&& __exec, _InputIterator __first, 
        _InputIterator __last, _OutputIterator __result, _Predicate __pred)
{
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__first, 1);
/*    __IteratorLoopStep(__result, 1);*/
    
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

// copy_n

template<class _ExecutionPolicy, class _InputIterator, class _Size, 
         class _OutputIterator>
inline _LIBCPP_INLINE_VISIBILITY 
_LIBCPP_CONSTEXPR_AFTER_CXX17_WITH_IS_CONSTANT_EVALUATED
typename enable_if
<
   __is_cpp17_input_iterator<_InputIterator>::value &&
   !__is_cpp17_random_access_iterator<_InputIterator>::value &&
   __cep::experimental::execution::is_constexpr_par_execution_policy<
         typename std::decay<_ExecutionPolicy>::type>::value,
    _OutputIterator
>::type
copy_n(_ExecutionPolicy&& __exec, _InputIterator __first, _Size __orig_n, 
       _OutputIterator __result)
{
    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;

    if (__n > 0)
    {
        *__result = *__first;
        ++__result;

        int __end = 0;
        __PartitionUsingIndex(__n, __end, EqualityType::GT);
        __IteratorLoopStep(__first, 1);
        __IteratorLoopStep(__result, 1);

        for (--__n; __n > __end; --__n)
        {
            ++__first;
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

template<class _ExecutionPolicy, class _InputIterator, class _Size, 
         class _OutputIterator>
inline _LIBCPP_INLINE_VISIBILITY 
_LIBCPP_CONSTEXPR_AFTER_CXX17_WITH_IS_CONSTANT_EVALUATED
typename enable_if
<
    __is_cpp17_random_access_iterator<_InputIterator>::value &&
    __cep::experimental::execution::is_constexpr_par_execution_policy<
         typename std::decay<_ExecutionPolicy>::type>::value,
    _OutputIterator
>::type
copy_n(_ExecutionPolicy&& __exec, _InputIterator __first, _Size __orig_n, 
       _OutputIterator __result)
{
    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    return _VSTD::__copy_constexpr(__exec, __first, __first + __n, __result);
}

// transform

template <class _ExecutionPolicy, class _InputIterator, class _OutputIterator, 
          class _UnaryOperation>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _OutputIterator>
transform(_ExecutionPolicy&& __exec, _InputIterator __first, 
          _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)
{
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__first, 1);
    __IteratorLoopStep(__result, 1);
    
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = __op(*__first);
    return __result;
}

template <class _ExecutionPolicy, class _InputIterator1, class _InputIterator2, 
          class _OutputIterator, class _BinaryOperation>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _OutputIterator>
transform(_ExecutionPolicy&& __exec, _InputIterator1 __first1, 
          _InputIterator1 __last1, _InputIterator2 __first2, 
          _OutputIterator __result, _BinaryOperation __binary_op)
{
    __BeginEndIteratorPair(__first1, __last1);
    __IteratorLoopStep(__first1, 1);
    __IteratorLoopStep(__first2, 1);
    __IteratorLoopStep(__result, 1);

    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)
        *__result = __binary_op(*__first1, *__first2);
    return __result;
}

// Taken from: https://tristanbrindle.com/posts/a-more-useful-compile-time-quicksort 
// libcxx's sort currently isn't constexpr and until I get around to tinkering 
// with it I thought borrowing this quicksort implementation for the time being
// is ideal!
namespace __details {

template <typename RAIt>
constexpr RAIt next(RAIt it,
                    typename std::iterator_traits<RAIt>::difference_type n = 1)
{
    return it + n;
}

template <typename RAIt>
constexpr auto distance(RAIt first, RAIt last) -> long
{
    return last - first;
}

template<class ForwardIt1, class ForwardIt2>
constexpr void iter_swap(ForwardIt1 a, ForwardIt2 b)
{
    auto temp = std::move(*a);
    *a = std::move(*b);
    *b = std::move(temp);
}

template<class InputIt, class UnaryPredicate>
constexpr InputIt find_if_not(InputIt first, InputIt last, UnaryPredicate q)
{
    for (; first != last; ++first) {
        if (!q(*first)) {
            return first;
        }
    }
    return last;
}

template<class ForwardIt, class UnaryPredicate>
constexpr ForwardIt partition(ForwardIt first, ForwardIt last, UnaryPredicate p)
{
    first = __details::find_if_not(first, last, p);
    if (first == last) return first;

    for(ForwardIt i = __details::next(first); i != last; ++i){
        if(p(*i)){
            __details::iter_swap(i, first);
            ++first;
        }
    }
    return first;
}

template<class RAIt, class Compare = std::less<typename std::iterator_traits<RAIt>::value_type>>
constexpr void quick_sort(RAIt first, RAIt last, Compare cmp = Compare{})
{
    using ElemType = typename std::iterator_traits<RAIt>::value_type;
    
    auto const N = __details::distance(first, last);
    if (N <= 1) return;
    auto const pivot = *__details::next(first, N / 2);

    auto const middle1 = __details::partition(first, last, 
      [=](ElemType const& elem){
        return cmp(elem, pivot);
    });
    auto const middle2 = __details::partition(middle1, last, 
      [=](ElemType const& elem){
        return !cmp(pivot, elem);
    });
    quick_sort(first, middle1, cmp); // assert(std::is_sorted(first, middle1, cmp));
    quick_sort(middle2, last, cmp);  // assert(std::is_sorted(middle2, last, cmp));
}

}

// set_intersection

template <class _Compare, class _InputIterator1, class _InputIterator2, 
          class _OutputIterator, class _ExecutionPolicy>
_LIBCPP_CONSTEXPR_AFTER_CXX17 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             _OutputIterator>
__set_intersection(_ExecutionPolicy&& __exec, _InputIterator1 __first1, 
                   _InputIterator1 __last1, _InputIterator2 __first2, 
                   _InputIterator2 __last2, _OutputIterator __result, 
                   _Compare __comp)
{
    auto __result_start = __result;
    
    __BeginEndIteratorPair(__first1, __last1);
    __IteratorLoopStep(__first1, 1);
    __ThreadLocalCopy(__first2);

    // TODO/FIXME: This implementation is very unoptimal, perhaps need to 
    // rollback to the much faster, but perhaps less "correct" implementation.
    //
    // While this implementation creates the correct results it's not incredibly
    // optimal as it makes use of a lock and then has to sort the results again
    // and the sorting algorithm is not parallelized at the moment. 
    //
    // Implementing the sort segment inside of the compiler as a reduction 
    // step via one of the wrapper functions like __ReduceVariable isn't simple 
    // as it requires invoking the equality operation within the compiler on 
    // each element to reorder the components. As for example having to reorder
    // an object with an overloaded equality operator of arbitrary complexity 
    // isn't feasible with a regular equality check (you could easily implement
    // a sort inside the compielr for base types like int, float etc.).
    //
    // The lock basically makes this run around the same speed as the normal 
    // set_intersection over a large set of values. The quick_sort algorithm
    // makes it run a fair chunk slower. The previous more incorrect 
    // implementation that worked without locks was quicker, but I'd have to
    for (; __first1 != __last1;) {
      if (__first2 == __last2)
        break;
        
      if (__comp(*__first1, *__first2)) {
        ++__first1;
      } else {
          if (!__comp(*__first2, *__first1))
          {
              __ThreadLock();
              *__result = *__first1;
              ++__result;
              __ThreadUnlock();
              ++__first1;
      
          }
          ++__first2;
      }
    }

    __details::quick_sort(__result_start, __result);

    return __result;
}

template <class _ExecutionPolicy, class _InputIterator1, class _InputIterator2, 
          class _OutputIterator, class _Compare>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             _OutputIterator>
set_intersection(_ExecutionPolicy&& __exec, _InputIterator1 __first1, 
                 _InputIterator1 __last1, _InputIterator2 __first2, 
                 _InputIterator2 __last2, _OutputIterator __result, 
                 _Compare __comp)
{
    typedef typename __comp_ref_type<_Compare>::type _Comp_ref;
    return __set_intersection<_Comp_ref>(__exec, __first1, __last1, __first2, 
                                         __last2, __result, __comp);
}

template <class _ExecutionPolicy, class _InputIterator1, class _InputIterator2, 
         class _OutputIterator>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             _OutputIterator>
set_intersection(_ExecutionPolicy&& __exec, _InputIterator1 __first1, 
                 _InputIterator1 __last1, _InputIterator2 __first2, 
                 _InputIterator2 __last2, _OutputIterator __result)
{
    return _VSTD::set_intersection(__exec, __first1, __last1, __first2, __last2, 
                                  __result, 
               __less<typename iterator_traits<_InputIterator1>::value_type,
                      typename iterator_traits<_InputIterator2>::value_type>());
}

// fill_n

template <class _ExecutionPolicy, class _OutputIterator, class _Size, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             _OutputIterator>
__fill_n(_ExecutionPolicy&& __exec, _OutputIterator __first, _Size __n, 
         const _Tp& __value_)
{
   // NOTE/FIXME: We do not handle literals at the moment, it's not 
    // simple to create thread independent values like it is for 
    // temproaries and arguments as they are not stored within the 
    // CallStackFrame. It's also not easily feasible to store them as 
    // temporaries. As temporaries need a pointer to the Expression or 
    // Declarator to access the APValue, however a literal has a new 
    // Expr for every literal i.e. the address of the literal passed to 
    // the loopwrapper function is not the same as the address of the 
    // literal in the for loop. The only way I can think of doing this 
    // for the time being is creating a new type of loop wrapper that will
    // return the literal value and it'll have to be used at the exact 
    // location the literal is being used. However, this would look weird,
    // be a little weird to reason about with the rest of the values and 
    // come at a performance cost. This can be attempted in the future, 
    // but for now it's simple to work around by using temporarily declared
    // variables in place of literals
    int __end = 0;
    __PartitionUsingIndex(__n, __end, EqualityType::GT);
    __IteratorLoopStep(__first, 1);
        
    for (; __n > __end; ++__first, (void) --__n)
        *__first = __value_;
    return __first;
}

template <class _ExecutionPolicy, class _OutputIterator, class _Size, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             _OutputIterator>
fill_n(_ExecutionPolicy&& __exec, _OutputIterator __first, _Size __n, 
       const _Tp& __value_)
{
   return _VSTD::__fill_n(__exec, __first, __convert_to_integral(__n), __value_);
}

// fill

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             void>
__fill(_ExecutionPolicy&& __exec, _ForwardIterator __first, 
       _ForwardIterator __last, const _Tp& __value_,  forward_iterator_tag)
{
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__first, 1);
    
    for (; __first != __last; ++__first)
        *__first = __value_;
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             void>
__fill(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, 
       _RandomAccessIterator __last,const _Tp& __value_, 
       random_access_iterator_tag)
{
    _VSTD::fill_n(__exec, __first, __last - __first, __value_);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             void>
fill(_ExecutionPolicy&& __exec, _ForwardIterator __first, 
     _ForwardIterator __last, const _Tp& __value_)
{
    _VSTD::__fill(__exec, __first, __last, __value_, 
        typename iterator_traits<_ForwardIterator>::iterator_category());
}

_LIBCPP_END_NAMESPACE_STD

_LIBCPP_POP_MACROS

#endif  // _LIBCPP_ALGORITHM


