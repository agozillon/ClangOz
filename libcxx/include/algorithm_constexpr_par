// -*- C++ -*-
//===-------------------- algorithm_constexpr_par -------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_ALGORITHM_CONSTEXPR_PAR
#define _LIBCPP_ALGORITHM_CONSTEXPR_PAR

#include <__algorithm/comp.h>
#include <__algorithm/comp_ref_type.h>
#include <__config>
#include <__cep_execution>
#include <initializer_list>
#include <type_traits>
#include <cstring>
#include <utility> // needed to provide swap_ranges.
#include <memory>
#include <iterator>
#include <cstddef>
#include <bit>
#include <version>

#include <__debug>

#include "loop_wrapper.h"

using namespace cest::loop_wrapper;

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_PUSH_MACROS
#include <__undef_macros>

_LIBCPP_BEGIN_NAMESPACE_STD

// TODO:
// 5) Perhaps these should all be made consteval, rather than constexpr as we 
//    don't really want these to be used outside of compile time, in every case
//    so far it'll work sequentially but is not guaranteed to be optimal/as 
//    performant as the true runtime sequential implementation
// 6) OK, so, the issue with checking for the execution policy in the compiler
//    as a parameter is that it'll mean that the execution policy cannot be 
//    passed around as a parameter. It'll pick it up and try parallelize where
//    it shouldn't.
//    1) Either we still need to filter by function name or namespace as well
//    2) Come up with some other indicator, like a wrapper function or function 
//       attribute to indicate it's in a constexpr parallel scope
//    3) Some segment of the execution policy that is perhaps switched on inside
//       of the function when we want to use it in a constexpr fashion
//    I am pretty sure the second one is the most apt... while I suppose in 
//    theory you could do the 3rd, it feels like a slightly more hacky solution.
//    currently number 1) is partially implemented it requires it to be in the
//    std:: library namespace and have an execution policy parameter

// TODO: Compiler
// 2) Fix the fact that the APValues actually get changed on the original at the
//    moment, even if they get set back correctly they really shouldn't be 
//    altered in the original until the end incase it creates some sideaffects.
// 3) test removal of:     __IteratorLoopStep(__result, 1); from 
//    set_intersection, there is a solid chance there will be a problem when 
//    everything is trying to write to the same point in the array but this 
//    is likely an issue that needs to be overcoem


// all_of

template <class _ExecutionPolicy, class _InputIterator, class _Predicate>
_LIBCPP_NODISCARD_EXT 
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              bool>
all_of(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, 
      _Predicate __pred)
{
    __BeginEndIteratorPair(__first, __last);
    
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            return false;
    return true;
}

// any_of

template <class _ExecutionPolicy, class _InputIterator, class _Predicate>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              bool>
any_of(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, 
       _Predicate __pred)
{
    __BeginEndIteratorPair(__first, __last);
    
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return true;
    return false;
}

// none_of

template <class _ExecutionPolicy, class _InputIterator, class _Predicate>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              bool>
none_of(_ExecutionPolicy&& __exec, _InputIterator __first, 
        _InputIterator __last, _Predicate __pred)
{
    __BeginEndIteratorPair(__first, __last);
    
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}


// for_each

template <class _ExecutionPolicy, class _ForwardIterator, class _Function>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              void>
for_each(_ExecutionPolicy&& __exec, _ForwardIterator __first, 
         _ForwardIterator __last, _Function __f)
{
/*    __ThreadLocalCopy(__first);*/
    __BeginEndIteratorPair(__first, __last);
    __ReduceVariable(__first, ReductionType::PartitionedOrderedAssign, 
                     OperatorType::PreInc);

    for (; __first != __last; ++__first)
        __f(*__first);
}

// for_each_n

template <class _ExecutionPolicy, class _InputIterator, class _Size, 
          class _Function>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _InputIterator>
for_each_n(_ExecutionPolicy&& __exec, _InputIterator __first, _Size __orig_n, 
           _Function __f)
{
    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    
    int __end = 0;
    __PartitionUsingIndex(__n, __end, EqualityType::GT);
    __IteratorLoopStep(__first, 1, OperatorType::PreInc);
    __ReduceVariable(__first, ReductionType::PartitionedOrderedAssign, 
                     OperatorType::PreInc);
    for (; __n > __end;  --__n) {
       __f(*__first);
       ++__first;
    }
    return __first;
}

// find

template <class _ExecutionPolicy, class _InputIterator, class _Tp>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _InputIterator>
find(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, 
     const _Tp& __value_)
{
    __BeginEndIteratorPair(__first, __last);

    for (; __first != __last; ++__first)
        if (*__first == __value_)
            break;
    return __first;
}

// find_if

template <class _ExecutionPolicy, class _InputIterator, class _Predicate>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _InputIterator>
find_if(_ExecutionPolicy&& __exec, _InputIterator __first, 
        _InputIterator __last, _Predicate __pred)
{
    __BeginEndIteratorPair(__first, __last);
    
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            break;
    return __first;
}

// find_if_not

template<class _ExecutionPolicy, class _InputIterator, class _Predicate>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _InputIterator>
find_if_not(_ExecutionPolicy&& __exec, _InputIterator __first, 
            _InputIterator __last, _Predicate __pred)
{
    __BeginEndIteratorPair(__first, __last);
    
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    return __first;
}

// find_first_of

template <class _ExecutionPolicy, class _ForwardIterator1, 
          class _ForwardIterator2, class _BinaryPredicate>
 constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _ForwardIterator1>
__find_first_of_ce(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, 
                   _ForwardIterator1 __last1, _ForwardIterator2 __first2, 
                   _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    // only parallelize/partition the outer loop
    __BeginEndIteratorPair(__first1, __last1);
/*    __IteratorLoopStep(__first1, 1);*/
        
    for (; __first1 != __last1; ++__first1)
        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)
            if (__pred(*__first1, *__j))
                return __first1;
    return __last1;
}


template <class _ExecutionPolicy, class _ForwardIterator1, 
          class _ForwardIterator2, class _BinaryPredicate>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _ForwardIterator1>
find_first_of(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, 
              _ForwardIterator1 __last1, _ForwardIterator2 __first2, 
              _ForwardIterator2 __last2, _BinaryPredicate __pred)
{
    return _VSTD::__find_first_of_ce(__exec, __first1, __last1, __first2, 
                                     __last2, __pred);
}

template <class _ExecutionPolicy, class _ForwardIterator1, 
          class _ForwardIterator2>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _ForwardIterator1>
find_first_of(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, 
              _ForwardIterator1 __last1, _ForwardIterator2 __first2, 
              _ForwardIterator2 __last2)
{
    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;
    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;
    return _VSTD::__find_first_of_ce(__exec, __first1, __last1, __first2, 
                                     __last2, __equal_to<__v1, __v2>());
}

// count

template <class _ExecutionPolicy, class _InputIterator, class _Tp>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                      _ExecutionPolicy, 
                      typename iterator_traits<_InputIterator>::difference_type>
count(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, 
      const _Tp& __value_)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
    
    __BeginEndIteratorPair(__first, __last);
    __ReduceVariable(__r, ReductionType::Accumulate, OperatorType::PreInc);
    
    for (; __first != __last; ++__first)
        if (*__first == __value_)
            ++__r;
    return __r;
}

// count_if

template <class _ExecutionPolicy, class _InputIterator, class _Predicate>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                      _ExecutionPolicy, 
                      typename iterator_traits<_InputIterator>::difference_type>
count_if(_ExecutionPolicy&& __exec, _InputIterator __first, 
         _InputIterator __last, _Predicate __pred)
{
    typename iterator_traits<_InputIterator>::difference_type __r(0);
 
    __BeginEndIteratorPair(__first, __last);
    __ReduceVariable(__r, ReductionType::Accumulate, OperatorType::PreInc);
    
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            ++__r;
    return __r;
}


// mismatch, TODO: Add Mismatch overload added in C++14

template <class _ExecutionPolicy, class _InputIterator1, class _InputIterator2, 
          class _BinaryPredicate>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                         _ExecutionPolicy, 
                                         pair<_InputIterator1, _InputIterator2>>
mismatch(_ExecutionPolicy&& __exec, _InputIterator1 __first1, 
         _InputIterator1 __last1, _InputIterator2 __first2, 
         _BinaryPredicate __pred)
{
    __BeginEndIteratorPair(__first1, __last1);
/*    __IteratorLoopStep(__first1, 1);*/
    __IteratorLoopStep(__first2, 1, OperatorType::PreInc);

    for (; __first1 != __last1; ++__first1, (void) ++__first2)
        if (!__pred(*__first1, *__first2))
            break;
    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
}

template <class _ExecutionPolicy, class _InputIterator1, class _InputIterator2>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                         _ExecutionPolicy, 
                                         pair<_InputIterator1, _InputIterator2>>
mismatch(_ExecutionPolicy&& __exec, _InputIterator1 __first1, 
         _InputIterator1 __last1, _InputIterator2 __first2)
{
    typedef typename iterator_traits<_InputIterator1>::value_type __v1;
    typedef typename iterator_traits<_InputIterator2>::value_type __v2;
    return _VSTD::mismatch(__exec, __first1, __last1, __first2, 
                           __equal_to<__v1, __v2>());
}

template <class _ExecutionPolicy, class _InputIterator, class _OutputIterator>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _OutputIterator>
__copy_constexpr(_ExecutionPolicy&& __exec, _InputIterator __first, 
                 _InputIterator __last, _OutputIterator __result)
{
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__result, 1, OperatorType::PreInc);
    __ReduceVariable(__result, ReductionType::PartitionedOrderedAssign, 
                     OperatorType::PreInc);
    
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = *__first;
    return __result;
}

template <class _ExecutionPolicy, class _InputIterator, class _OutputIterator>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _OutputIterator>
copy(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, 
     _OutputIterator __result)
{
    return _VSTD::__copy_constexpr(__exec,
        __unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));
}


// copy_backward
// This doesn't seem to have an execution policy overload but it seems simple to
// implement for us.

template <class _ExecutionPolicy, class _BidirectionalIterator, 
          class _OutputIterator>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy,
                                                              _OutputIterator>
__copy_backward_constexpr(_ExecutionPolicy&& __exec, 
                          _BidirectionalIterator __first, 
                          _BidirectionalIterator __last, 
                          _OutputIterator __result)
{
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__result, 1, OperatorType::PreDec);
    __ReduceVariable(__result, ReductionType::PartitionedOrderedAssign, 
                     OperatorType::PreDec);
    
    for (; __first != __last;)
        *--__result = *--__last;

    return __result;
}

template <class _ExecutionPolicy, class _BidirectionalIterator, 
          class _OutputIterator>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy,
                                                              _OutputIterator>
__copy_backward(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, 
                _BidirectionalIterator __last, _OutputIterator __result)
{
    return __copy_backward_constexpr(__exec, __first, __last, __result);
}


template <class _ExecutionPolicy, class _BidirectionalIterator1, 
          class _BidirectionalIterator2>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                        _ExecutionPolicy, 
                                                        _BidirectionalIterator2>
copy_backward(_ExecutionPolicy&& __exec, _BidirectionalIterator1 __first, 
              _BidirectionalIterator1 __last, _BidirectionalIterator2 __result)
{
    return _VSTD::__copy_backward_constexpr(__exec, __unwrap_iter(__first),
                                            __unwrap_iter(__last),
                                            __unwrap_iter(__result));
}

// copy_if

template<class _ExecutionPolicy, class _InputIterator, class _OutputIterator, 
         class _Predicate>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _OutputIterator>
copy_if(_ExecutionPolicy&& __exec, _InputIterator __first, 
        _InputIterator __last, _OutputIterator __result, _Predicate __pred)
{
    __BeginEndIteratorPair(__first, __last);
/*    __IteratorLoopStep(__first, 1);*/
/*    __IteratorLoopStep(__result, 1);*/
    
    for (; __first != __last; ++__first)
    {
        if (__pred(*__first))
        {
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

// copy_n

template<class _ExecutionPolicy, class _InputIterator, class _Size, 
         class _OutputIterator>
inline _LIBCPP_INLINE_VISIBILITY 
 constexpr 
typename enable_if
<
   __is_cpp17_input_iterator<_InputIterator>::value &&
   !__is_cpp17_random_access_iterator<_InputIterator>::value &&
   __cep::experimental::execution::is_constexpr_par_execution_policy<
         typename std::decay<_ExecutionPolicy>::type>::value,
    _OutputIterator
>::type
copy_n(_ExecutionPolicy&& __exec, _InputIterator __first, _Size __orig_n, 
       _OutputIterator __result)
{
    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;

    if (__n > 0)
    {
        *__result = *__first;
        ++__result;

        int __end = 0;
        __PartitionUsingIndex(__n, __end, EqualityType::GT);
        __IteratorLoopStep(__first, 1, OperatorType::PreInc);
        __IteratorLoopStep(__result, 1, OperatorType::PreInc);
        __ReduceVariable(__result, ReductionType::PartitionedOrderedAssign, 
                         OperatorType::PreDec);
                     
        for (--__n; __n > __end; --__n)
        {
            ++__first;
            *__result = *__first;
            ++__result;
        }
    }
    return __result;
}

template<class _ExecutionPolicy, class _InputIterator, class _Size, 
         class _OutputIterator>
inline _LIBCPP_INLINE_VISIBILITY 
 constexpr 
typename enable_if
<
    __is_cpp17_random_access_iterator<_InputIterator>::value &&
    __cep::experimental::execution::is_constexpr_par_execution_policy<
         typename std::decay<_ExecutionPolicy>::type>::value,
    _OutputIterator
>::type
copy_n(_ExecutionPolicy&& __exec, _InputIterator __first, _Size __orig_n, 
       _OutputIterator __result)
{
    typedef decltype(__convert_to_integral(__orig_n)) _IntegralSize;
    _IntegralSize __n = __orig_n;
    return _VSTD::__copy_constexpr(__exec, __first, __first + __n, __result);
}

// move

template <class _ExecutionPolicy, class _InputIterator, class _OutputIterator>
inline _LIBCPP_INLINE_VISIBILITY  constexpr  
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             _OutputIterator>
__move(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, 
       _OutputIterator __result)
{
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__result, 1, OperatorType::PreInc);
    __ReduceVariable(__result, ReductionType::PartitionedOrderedAssign, 
                     OperatorType::PreInc);
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = _VSTD::move(*__first);
    return __result;
}

// Technically this can't be parallelized (without possible modification of the 
// builtin) as it basically calls a builtin memmove, this is however possibly 
// faster than the parallelized verion for things like std::array.
//
// It also appears that memmove does not have a constexpr counterpart..?
/*template <class _ExecutionPolicy, class _Tp, class _Up>*/
/*inline _LIBCPP_INLINE_VISIBILITY  constexpr */
/*typename enable_if*/
/*<*/
/*    is_same<typename remove_const<_Tp>::type, _Up>::value &&*/
/*    is_trivially_copy_assignable<_Up>::value &&*/
/*    __cep::experimental::execution::is_constexpr_par_execution_policy<*/
/*         typename std::decay<_ExecutionPolicy>::type>::value,*/
/*    _Up**/
/*>::type*/
/*__move(_ExecutionPolicy&& __exec, _Tp* __first, _Tp* __last, _Up* __result)*/
/*{*/
/*    const size_t __n = static_cast<size_t>(__last - __first);*/
/*    if (__n > 0)*/
/*        _VSTD::memmove(__result, __first, __n * sizeof(_Up));*/
/*    return __result + __n;*/
/*}*/

template <class _ExecutionPolicy, class _InputIterator, class _OutputIterator>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             _OutputIterator>
move(_ExecutionPolicy&& __exec, _InputIterator __first, _InputIterator __last, 
     _OutputIterator __result)
{
    return _VSTD::__move(__exec, __unwrap_iter(__first), __unwrap_iter(__last), 
                         __unwrap_iter(__result));
}

// move_backward

template <class _ExecutionPolicy, class _InputIterator, class _OutputIterator>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             _OutputIterator>
__move_backward(_ExecutionPolicy&& __exec, _InputIterator __first, 
                _InputIterator __last, _OutputIterator __result)
{
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__result, 1, OperatorType::PreDec);
    __ReduceVariable(__result, ReductionType::PartitionedOrderedAssign, 
                     OperatorType::PreDec);
                 
    for (; __first != __last;)
        *--__result = _VSTD::move(*--__last);
    return __result;
}

// Same reasons as the other trivially copyable __move function
/*template <class _ExecutionPolicy, class _Tp, class _Up>*/
/*inline _LIBCPP_INLINE_VISIBILITY  constexpr */
/*typename enable_if*/
/*<*/
/*    is_same<typename remove_const<_Tp>::type, _Up>::value &&*/
/*    is_trivially_copy_assignable<_Up>::value &&*/
/*    __cep::experimental::execution::is_constexpr_par_execution_policy<*/
/*         typename std::decay<_ExecutionPolicy>::type>::value,*/
/*    _Up**/
/*>::type*/
/*__move_backward(_ExecutionPolicy&& __exec, _Tp* __first, _Tp* __last, */
/*                _Up* __result)*/
/*{*/
/*    const size_t __n = static_cast<size_t>(__last - __first);*/
/*    if (__n > 0)*/
/*    {*/
/*        __result -= __n;*/
/*        _VSTD::memmove(__result, __first, __n * sizeof(_Up));*/
/*    }*/
/*    return __result;*/
/*}*/

template <class _ExecutionPolicy, class _BidirectionalIterator1, 
          class _BidirectionalIterator2>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                       _ExecutionPolicy, 
                                                       _BidirectionalIterator2>
move_backward(_ExecutionPolicy&& __exec, _BidirectionalIterator1 __first, 
              _BidirectionalIterator1 __last, _BidirectionalIterator2 __result)
{
    return _VSTD::__move_backward(__exec, __unwrap_iter(__first), 
                                  __unwrap_iter(__last), 
                                  __unwrap_iter(__result));
}

// transform

template <class _ExecutionPolicy, class _InputIterator, class _OutputIterator, 
          class _UnaryOperation>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _OutputIterator>
transform(_ExecutionPolicy&& __exec, _InputIterator __first, 
          _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)
{
/*    __ThreadLocalCopy(__result);*/
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__result, 1, OperatorType::PreInc);
    __ReduceVariable(__result, ReductionType::PartitionedOrderedAssign, 
                     OperatorType::PreInc);
                     
    for (; __first != __last; ++__first, (void) ++__result)
        *__result = __op(*__first);
    return __result;
}

template <class _ExecutionPolicy, class _InputIterator1, class _InputIterator2, 
          class _OutputIterator, class _BinaryOperation>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy, 
                                                              _OutputIterator>
transform(_ExecutionPolicy&& __exec, _InputIterator1 __first1, 
          _InputIterator1 __last1, _InputIterator2 __first2, 
          _OutputIterator __result, _BinaryOperation __binary_op)
{
/*    __ThreadLocalCopy(__result);*/
/*    __ThreadLocalCopy(__first2);*/
/*    __ThreadLocalCopy(__first1);*/
/*    */
    __BeginEndIteratorPair(__first1, __last1);
    __IteratorLoopStep(__first2, 1, OperatorType::PreInc);
    __IteratorLoopStep(__result, 1, OperatorType::PreInc);
    __ReduceVariable(__result, ReductionType::PartitionedOrderedAssign, 
                     OperatorType::PreInc);


    for (; __first1 != __last1; ++__first1, (void) ++__first2, ++__result)
        *__result = __binary_op(*__first1, *__first2);
    return __result;
}

// replace

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy,
                                                              void>
replace(_ExecutionPolicy&& __exec, _ForwardIterator __first, 
        _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)
{
    __BeginEndIteratorPair(__first, __last);
    __ReduceVariable(__first, ReductionType::PartitionedOrderedAssign, 
                     OperatorType::PreInc);
                     
    for (; __first != __last; ++__first)
        if (*__first == __old_value)
            *__first = __new_value;
}

// replace_if

template <class _ExecutionPolicy, class _ForwardIterator, class _Predicate, 
          class _Tp>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy,
                                                              void>
replace_if(_ExecutionPolicy&& __exec, _ForwardIterator __first, 
           _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)
{
    __BeginEndIteratorPair(__first, __last);
    __ReduceVariable(__first, ReductionType::PartitionedOrderedAssign, 
                     OperatorType::PreInc);
                     
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            *__first = __new_value;
}

// replace_copy

template <class _ExecutionPolicy, class _InputIterator, 
          class _OutputIterator, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy,
                                                              _OutputIterator>
replace_copy(_ExecutionPolicy&& __exec, _InputIterator __first, 
             _InputIterator __last, _OutputIterator __result,
             const _Tp& __old_value, const _Tp& __new_value)
{
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__result, 1, OperatorType::PreInc);
    __ReduceVariable(__result, ReductionType::PartitionedOrderedAssign, 
                     OperatorType::PreInc);
                     
    for (; __first != __last; ++__first, (void) ++__result)
        if (*__first == __old_value)
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}

// replace_copy_if

template <class _ExecutionPolicy, class _InputIterator, class _OutputIterator, 
          class _Predicate, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                              _ExecutionPolicy,
                                                              _OutputIterator>
replace_copy_if(_ExecutionPolicy&& __exec, _InputIterator __first, 
                _InputIterator __last, _OutputIterator __result,
                _Predicate __pred, const _Tp& __new_value)
{
    __BeginEndIteratorPair(__first, __last);
    __IteratorLoopStep(__result, 1, OperatorType::PreInc);
    __ReduceVariable(__result, ReductionType::PartitionedOrderedAssign, 
                     OperatorType::PreInc);
                     
    for (; __first != __last; ++__first, (void) ++__result)
        if (__pred(*__first))
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}

// reverse

/*template <class _ExecutionPolicy, class _BidirectionalIterator>*/
/*inline _LIBCPP_INLINE_VISIBILITY  constexpr */
/*__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<*/
/*                                                              _ExecutionPolicy,*/
/*                                                              void>*/
/*__reverse(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, */
/*          _BidirectionalIterator __last, bidirectional_iterator_tag)*/
/*{*/
/*    while (__first != __last)*/
/*    {*/
/*        if (__first == --__last)*/
/*            break;*/
/*        _VSTD::iter_swap(__first, __last);*/
/*        ++__first;*/
/*    }*/
/*}*/

/*template <class _ExecutionPolicy, class _RandomAccessIterator>*/
/*inline _LIBCPP_INLINE_VISIBILITY  constexpr */
/*__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<*/
/*                                                              _ExecutionPolicy,*/
/*                                                              void>*/
/*__reverse(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, */
/*          _RandomAccessIterator __last, random_access_iterator_tag)*/
/*{*/
/*    __BeginEndIteratorPair(__first, __last);*/
/*    __IteratorLoopStep(__result, 1, OperatorType::PreInc);*/
/*    */
/*    if (__first != __last)*/
/*        for (; __first < --__last; ++__first)*/
/*            _VSTD::iter_swap(__first, __last);*/
/*}*/

/*template <class _ExecutionPolicy, class _BidirectionalIterator>*/
/*inline _LIBCPP_INLINE_VISIBILITY  constexpr */
/*__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<*/
/*                                                              _ExecutionPolicy,*/
/*                                                              void>*/
/*reverse(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, */
/*        _BidirectionalIterator __last)*/
/*{*/
/*    _VSTD::__reverse(__exec, __first, __last, */
/*        typename iterator_traits<_BidirectionalIterator>::iterator_category());*/
/*}*/

// reverse_copy

/*template <class _ExecutionPolicy, class _BidirectionalIterator, */
/*          class _OutputIterator>*/
/*inline _LIBCPP_INLINE_VISIBILITY  constexpr */
/*__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<*/
/*                                                              _ExecutionPolicy,*/
/*                                                              _OutputIterator>*/
/*reverse_copy(_ExecutionPolicy&& __exec, _BidirectionalIterator __first, */
/*             _BidirectionalIterator __last, _OutputIterator __result)*/
/*{*/
/*    __BeginEndIteratorPair(__first, __last);*/
/*    __IteratorLoopStep(__result, 1, OperatorType::PreInc);*/
/* */
/*    for (; __first != __last; ++__result)*/
/*        *__result = *--__last;*/
/*    return __result;*/
/*}*/


// Taken from: https://tristanbrindle.com/posts/a-more-useful-compile-time-quicksort 
// libcxx's sort currently isn't constexpr and until I get around to tinkering 
// with it I thought borrowing this quicksort implementation for the time being
// is ideal!
namespace __details {

template <typename RAIt>
constexpr RAIt next(RAIt it,
                    typename std::iterator_traits<RAIt>::difference_type n = 1)
{
    return it + n;
}

template <typename RAIt>
constexpr auto distance(RAIt first, RAIt last) -> long
{
    return last - first;
}

template<class ForwardIt1, class ForwardIt2>
constexpr void iter_swap(ForwardIt1 a, ForwardIt2 b)
{
    auto temp = std::move(*a);
    *a = std::move(*b);
    *b = std::move(temp);
}

template<class InputIt, class UnaryPredicate>
constexpr InputIt find_if_not(InputIt first, InputIt last, UnaryPredicate q)
{
    for (; first != last; ++first) {
        if (!q(*first)) {
            return first;
        }
    }
    return last;
}

template<class ForwardIt, class UnaryPredicate>
constexpr ForwardIt partition(ForwardIt first, ForwardIt last, UnaryPredicate p)
{
    first = __details::find_if_not(first, last, p);
    if (first == last) return first;

    for(ForwardIt i = __details::next(first); i != last; ++i){
        if(p(*i)){
            __details::iter_swap(i, first);
            ++first;
        }
    }
    return first;
}

template<class RAIt, class Compare = std::less<typename std::iterator_traits<RAIt>::value_type>>
constexpr void quick_sort(RAIt first, RAIt last, Compare cmp = Compare{})
{
    using ElemType = typename std::iterator_traits<RAIt>::value_type;
    
    auto const N = __details::distance(first, last);
    if (N <= 1) return;
    auto const pivot = *__details::next(first, N / 2);

    auto const middle1 = __details::partition(first, last, 
      [=](ElemType const& elem){
        return cmp(elem, pivot);
    });
    auto const middle2 = __details::partition(middle1, last, 
      [=](ElemType const& elem){
        return !cmp(pivot, elem);
    });
    quick_sort(first, middle1, cmp); // assert(std::is_sorted(first, middle1, cmp));
    quick_sort(middle2, last, cmp);  // assert(std::is_sorted(middle2, last, cmp));
}

}

// set_intersection

template <class _Compare, class _InputIterator1, class _InputIterator2, 
          class _OutputIterator, class _ExecutionPolicy>
 constexpr  
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             _OutputIterator>
__set_intersection(_ExecutionPolicy&& __exec, _InputIterator1 __first1, 
                   _InputIterator1 __last1, _InputIterator2 __first2, 
                   _InputIterator2 __last2, _OutputIterator __result, 
                   _Compare __comp)
{
    auto __result_start = __result;
    
    __BeginEndIteratorPair(__first1, __last1);
    __ReduceVariable(__result, ReductionType::OrderedAssign, 
                     OperatorType::PreInc);

    for (; __first1 != __last1;) {
      if (__first2 == __last2)
        break;
        
      if (__comp(*__first1, *__first2)) {
        ++__first1;
      } else {
          if (!__comp(*__first2, *__first1))
          {
              *__result = *__first1;
              ++__result;
              ++__first1;
      
          }
          ++__first2;
      }
    }
    
    return __result;
}

template <class _ExecutionPolicy, class _InputIterator1, class _InputIterator2, 
          class _OutputIterator, class _Compare>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             _OutputIterator>
set_intersection(_ExecutionPolicy&& __exec, _InputIterator1 __first1, 
                 _InputIterator1 __last1, _InputIterator2 __first2, 
                 _InputIterator2 __last2, _OutputIterator __result, 
                 _Compare __comp)
{
    return __set_intersection< __comp_ref_type<_Compare> >(__exec, __first1, __last1, __first2, 
                                         __last2, __result, __comp);
}

template <class _ExecutionPolicy, class _InputIterator1, class _InputIterator2, 
         class _OutputIterator>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             _OutputIterator>
set_intersection(_ExecutionPolicy&& __exec, _InputIterator1 __first1, 
                 _InputIterator1 __last1, _InputIterator2 __first2, 
                 _InputIterator2 __last2, _OutputIterator __result)
{
    return _VSTD::set_intersection(__exec, __first1, __last1, __first2, __last2, 
                                  __result, 
               __less<typename iterator_traits<_InputIterator1>::value_type,
                      typename iterator_traits<_InputIterator2>::value_type>());
}

// fill_n

template <class _ExecutionPolicy, class _OutputIterator, class _Size, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             _OutputIterator>
__fill_n(_ExecutionPolicy&& __exec, _OutputIterator __first, _Size __n, 
         const _Tp& __value_)
{
   // NOTE/FIXME: We do not handle literals at the moment, it's not 
    // simple to create thread independent values like it is for 
    // temproaries and arguments as they are not stored within the 
    // CallStackFrame. It's also not easily feasible to store them as 
    // temporaries. As temporaries need a pointer to the Expression or 
    // Declarator to access the APValue, however a literal has a new 
    // Expr for every literal i.e. the address of the literal passed to 
    // the loopwrapper function is not the same as the address of the 
    // literal in the for loop. The only way I can think of doing this 
    // for the time being is creating a new type of loop wrapper that will
    // return the literal value and it'll have to be used at the exact 
    // location the literal is being used. However, this would look weird,
    // be a little weird to reason about with the rest of the values and 
    // come at a performance cost. This can be attempted in the future, 
    // but for now it's simple to work around by using temporarily declared
    // variables in place of literals
    int __end = 0;
    __PartitionUsingIndex(__n, __end, EqualityType::GT);
    __IteratorLoopStep(__first, 1, OperatorType::PreInc);
    __ReduceVariable(__first, ReductionType::PartitionedOrderedAssign, 
                     OperatorType::PreInc);
                     
    for (; __n > __end; ++__first, (void) --__n)
        *__first = __value_;
    return __first;
}

template <class _ExecutionPolicy, class _OutputIterator, class _Size, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             _OutputIterator>
fill_n(_ExecutionPolicy&& __exec, _OutputIterator __first, _Size __n, 
       const _Tp& __value_)
{
   return _VSTD::__fill_n(__exec, __first, __convert_to_integral(__n), __value_);
}

// fill

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             void>
__fill(_ExecutionPolicy&& __exec, _ForwardIterator __first, 
       _ForwardIterator __last, const _Tp& __value_,  forward_iterator_tag)
{
    __BeginEndIteratorPair(__first, __last);
    
    for (; __first != __last; ++__first)
        *__first = __value_;
}

template <class _ExecutionPolicy, class _RandomAccessIterator, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             void>
__fill(_ExecutionPolicy&& __exec, _RandomAccessIterator __first, 
       _RandomAccessIterator __last,const _Tp& __value_, 
       random_access_iterator_tag)
{
    _VSTD::fill_n(__exec, __first, __last - __first, __value_);
}

template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             void>
fill(_ExecutionPolicy&& __exec, _ForwardIterator __first, 
     _ForwardIterator __last, const _Tp& __value_)
{
    _VSTD::__fill(__exec, __first, __last, __value_, 
        typename iterator_traits<_ForwardIterator>::iterator_category());
}

// remove

// NOTE/FIXME: This will suffer from similar problems to set_intersection, its
// feasible to do it currently but it will not be optimal need to think of a 
// good way to implement this form of algorithm.
//
// It's also feasible that you cannot split __first using __IteratorLoopStep 
// as it has a chance of writing to an element "owned" by another thread, 
// it will perhaps require a copy of the array per thread and then to merge
// them again cohesively.
template <class _ExecutionPolicy, class _ForwardIterator, class _Tp>
_LIBCPP_NODISCARD_EXT  constexpr  
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             _ForwardIterator>
remove(_ExecutionPolicy&& __exec, _ForwardIterator __first, 
       _ForwardIterator __last, const _Tp& __value_)
{
    __first = _VSTD::find(__exec, __first, __last, __value_);
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        
        __BeginEndIteratorPair(__i, __last);
        __IteratorLoopStep(__first, 1, OperatorType::PreInc);
        __ReduceVariable(__first, ReductionType::PartitionedOrderedAssign, 
                         OperatorType::PreInc);
                     
        for (; ++__i != __last;)
        {
            if (!(*__i == __value_))
            {
                *__first = _VSTD::move(*__i);
                ++__first;
            }
        }
    }
    return __first;
}

// swap_ranges, technically in libcxx this algorithm resides in utility, but 
// there is no real reason to create a new utility_constexpr_par file just for 
// this.
template <class _ExecutionPolicy, class _ForwardIterator1, 
          class _ForwardIterator2>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             _ForwardIterator2>
swap_ranges(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, 
            _ForwardIterator1 __last1, _ForwardIterator2 __first2);

// These are basically the same swaps that exist in utility but ive specialized 
// them so that we can in theory call swap_ranges in a constexpr parallel 
// context from iter_swap, which uses swap.
template <class _ExecutionPolicy, class _Tp>
inline _LIBCPP_INLINE_VISIBILITY
typename enable_if
<
    is_move_constructible<_Tp>::value &&
    is_move_assignable<_Tp>::value && 
     __cep::experimental::execution::is_constexpr_par_execution_policy<
       typename std::decay<_ExecutionPolicy>::type>::value
>::type
 constexpr 
swap(_ExecutionPolicy&& __exec, _Tp& __x, _Tp& __y) 
    _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&
               is_nothrow_move_assignable<_Tp>::value)
{
    _Tp __t(_VSTD::move(__x));
    __x = _VSTD::move(__y);
    __y = _VSTD::move(__t);
}

template<class _ExecutionPolicy, class _Tp, size_t _Np>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
typename enable_if<
    __is_swappable<_Tp>::value &&
    __cep::experimental::execution::is_constexpr_par_execution_policy<
        typename std::decay<_ExecutionPolicy>::type>::value
>::type
swap(_ExecutionPolicy&& __exec, _Tp (&__a)[_Np], 
     _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value)
{
    _VSTD::swap_ranges(__exec, __a, __a + _Np, __b);
}

template <class _ExecutionPolicy, class _ForwardIterator1, 
          class _ForwardIterator2>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             _ForwardIterator2>
swap_ranges(_ExecutionPolicy&& __exec, _ForwardIterator1 __first1, 
            _ForwardIterator1 __last1, _ForwardIterator2 __first2)
{
    __BeginEndIteratorPair(__first1, __last1);
    __IteratorLoopStep(__first2, 1, OperatorType::PreInc);
    __ReduceVariable(__first1, ReductionType::PartitionedOrderedAssign, 
                     OperatorType::PreInc);
    __ReduceVariable(__first2, ReductionType::PartitionedOrderedAssign, 
                     OperatorType::PreInc);

    for(; __first1 != __last1; ++__first1, (void) ++__first2)
        swap(*__first1, *__first2);
    return __first2;
}

// iter_swap, this is currently only really parallelized in the really specific 
// case that the iterator passed in points to an regular array, in which case 
// it'll select the swap that calls swap_ranges, otherwise it'll fall into the
// std::move variation which is dependent on the move constructor of the object
// in general iter_swap only really swaps the initial element pointed to by the  
// iterators, so the parallelization is only really going to happen in the case
// of nested objects.
template <class _ExecutionPolicy, class _ForwardIterator1, 
          class _ForwardIterator2>
inline _LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy, 
                                                             void>
iter_swap(_ExecutionPolicy&& __exec, _ForwardIterator1 __a, 
          _ForwardIterator2 __b)
               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),
                                          *_VSTD::declval<_ForwardIterator2>())))
{
    swap(__exec, *__a, *__b);
}

// unique_copy

/*template <class _ExecutionPolicy, class _BinaryPredicate, class _InputIterator,*/
/*          class _OutputIterator>*/
/* constexpr  */
/*__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<*/
/*                                                             _ExecutionPolicy,*/
/*                                                             _OutputIterator>*/
/*__unique_copy(_ExecutionPolicy&& __exec, _InputIterator __first, */
/*              _InputIterator __last, _OutputIterator __result, */
/*              _BinaryPredicate __pred, input_iterator_tag, output_iterator_tag)*/
/*{*/
/*    if (__first != __last)*/
/*    {*/
/*        typename iterator_traits<_InputIterator>::value_type __t(*__first);*/
/*        *__result = __t;*/
/*        ++__result;*/
/*        while (++__first != __last)*/
/*        {*/
/*            if (!__pred(__t, *__first))*/
/*            {*/
/*                __t = *__first;*/
/*                *__result = __t;*/
/*                ++__result;*/
/*            }*/
/*        }*/
/*    }*/
/*    return __result;*/
/*}*/

/*template <class _ExecutionPolicy, class _BinaryPredicate, */
/*          class _ForwardIterator, class _OutputIterator>*/
/* constexpr  */
/*__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<*/
/*                                                             _ExecutionPolicy,*/
/*                                                             _OutputIterator>*/
/*__unique_copy(_ExecutionPolicy&& __exec, _ForwardIterator __first, */
/*              _ForwardIterator __last, _OutputIterator __result, */
/*              _BinaryPredicate __pred, forward_iterator_tag, */
/*              output_iterator_tag)*/
/*{*/
/*    if (__first != __last)*/
/*    {*/
/*        _ForwardIterator __i = __first;*/
/*        *__result = *__i;*/
/*        ++__result;*/
/*        while (++__first != __last)*/
/*        {*/
/*            if (!__pred(*__i, *__first))*/
/*            {*/
/*                *__result = *__first;*/
/*                ++__result;*/
/*                __i = __first;*/
/*            }*/
/*        }*/
/*    }*/
/*    return __result;*/
/*}*/

/*template <class _ExecutionPolicy, class _BinaryPredicate, class _InputIterator, */
/*          class _ForwardIterator>*/
/* constexpr  */
/*__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<*/
/*                                                             _ExecutionPolicy,*/
/*                                                             _ForwardIterator>*/
/*__unique_copy(_ExecutionPolicy&& __exec, _InputIterator __first, */
/*              _InputIterator __last, _ForwardIterator __result, */
/*              _BinaryPredicate __pred, input_iterator_tag, forward_iterator_tag)*/
/*{*/
/*    if (__first != __last)*/
/*    {*/
/*        *__result = *__first;*/
/*        for (; ++__first != __last;)*/
/*            if (!__pred(*__result, *__first))*/
/*                *++__result = *__first;*/
/*        ++__result;*/
/*    }*/
/*    return __result;*/
/*}*/

/*template <class _ExecutionPolicy, class _InputIterator, class _OutputIterator, */
/*          class _BinaryPredicate>*/
/*inline _LIBCPP_INLINE_VISIBILITY  constexpr */
/*__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<*/
/*                                                             _ExecutionPolicy,*/
/*                                                             _OutputIterator>*/
/*unique_copy(_ExecutionPolicy&& __exec, _InputIterator __first, */
/*            _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)*/
/*{*/
/*    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>*/
/*                              (__exec, __first, __last, __result, __pred,*/
/*                               typename iterator_traits<_InputIterator>::iterator_category(),*/
/*                               typename iterator_traits<_OutputIterator>::iterator_category());*/
/*}*/

/*template <class _ExecutionPolicy, class _InputIterator, class _OutputIterator>*/
/*inline _LIBCPP_INLINE_VISIBILITY  constexpr */
/*__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<*/
/*                                                             _ExecutionPolicy,*/
/*                                                             _OutputIterator>*/
/*unique_copy(_ExecutionPolicy&& __exec, _InputIterator __first, */
/*             _InputIterator __last, _OutputIterator __result)*/
/*{*/
/*    typedef typename iterator_traits<_InputIterator>::value_type __v;*/
/*    return _VSTD::unique_copy(__exec, __first, __last, __result, */
/*                              __equal_to<__v>());*/
/*}*/

// is_sorted_until

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
_LIBCPP_NODISCARD_EXT  constexpr  
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy,
                                                             _ForwardIterator>
is_sorted_until(_ExecutionPolicy&& __exec,  _ForwardIterator __first, 
                _ForwardIterator __last, _Compare __comp)
{
    if (__first != __last)
    {
        _ForwardIterator __i = __first;
        
        __BeginEndIteratorPair(__i, __last);
        __IteratorLoopStep(__first, 1, OperatorType::PreInc);
    
        for (; ++__i != __last;)
        {
            if (__comp(*__i, *__first))
                return __i;
            __first = __i;
        }
    }
    return __last;
}

template<class _ExecutionPolicy, class _ForwardIterator>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy,
                                                             _ForwardIterator>
is_sorted_until(_ExecutionPolicy&& __exec,  _ForwardIterator __first, 
                _ForwardIterator __last)
{
    return _VSTD::is_sorted_until(__exec, __first, __last, 
        __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

// is_sorted

template <class _ExecutionPolicy, class _ForwardIterator, class _Compare>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy,
                                                             bool>
is_sorted(_ExecutionPolicy&& __exec, _ForwardIterator __first, 
          _ForwardIterator __last, _Compare __comp)
{
    return _VSTD::is_sorted_until(__exec, __first, __last, __comp) == __last;
}

template<class _ExecutionPolicy, class _ForwardIterator>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy,
                                                             bool>
is_sorted(_ExecutionPolicy&& __exec, _ForwardIterator __first, 
          _ForwardIterator __last)
{
    return _VSTD::is_sorted(__exec, __first, __last, 
        __less<typename iterator_traits<_ForwardIterator>::value_type>());
}

template <class _ExecutionPolicy, class _InputIterator, class _Predicate>
_LIBCPP_NODISCARD_EXT  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy,
                                                             bool>
is_partitioned(_ExecutionPolicy&& __exec, _InputIterator __first, 
               _InputIterator __last, _Predicate __pred)
{
    // TODO/FIXME: this currently covers both loops, the only reason this works 
    // is because both loops use __first and __last, at the moment there is no 
    // way to tie a wrapper to a specfic loop. In reality we will likely have to
    // check for wrappers within/immediately above the function body and 
    // prioritize those
    __BeginEndIteratorPair(__first, __last);
    __ImmutableVariable(__last);
    
    for (; __first != __last; ++__first)
        if (!__pred(*__first))
            break;
    if ( __first == __last )
        return true;
    ++__first;
    for (; __first != __last; ++__first)
        if (__pred(*__first))
            return false;
    return true;
}

// lexicographical_compare

template <class _Compare, class _ExecutionPolicy, class _InputIterator1, 
          class _InputIterator2>
 constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy,
                                                             bool>
__lexicographical_compare(_ExecutionPolicy&& __exec, _InputIterator1 __first1, 
                          _InputIterator1 __last1, _InputIterator2 __first2, 
                          _InputIterator2 __last2, _Compare __comp)
{

// can use this to "purge" the CXX constructor which may cause issues
/*    __BeginEndIteratorPair(&__first2, &__last2);*/
    __BeginEndIteratorPair(__first2, __last2);
    
    // This function raises an issue, what happens if the loop bounded by 
    // __first2 and __last2 is larger than what's supplied by __first1/__last1? 
    // As we must offset __first1 to the the same offset as every __first2, but 
    // the algorithm doesn't neccisitate that the data in __first1 has to the 
    // same size. This is OK if it's larger, but if it's smaller we run into the
    // issue of indexing past the end of the data, which in an array is an error
    // in a constexpr context. There is only two ways I can think of fixing this
    // and for the moment I've opted for the first:
    // 1) I can bound the iteration space if there is a __last iterator for it 
    //   however, not all algorithms have one (although not all have this 
    //   problem) and not all algorithms have a "linear" index space as they are
    //   not contigious. But that seems like a larger issue.
    // 2) I could dig for a size using the compiler, however this only really 
    //    works for arrays and it'll come at a cost as 1) I need to convert the
    //    iterator to the type the data belongs to (an std::array or an array) 
    //    2) if it's an std::array there is still more work to do as it's a 
    //    struct so I have to dig for the underlying array to get the bound. It
    //    may be feasible to also do this approach for other std containers as 
    //    well that contain a size parameter though.
    __IteratorLoopStep(__first1, 1, OperatorType::PreInc, __last1);

    for (; __first2 != __last2; ++__first1, (void) ++__first2)
    {
        if (__first1 == __last1 || __comp(*__first1, *__first2))
            return true;
        if (__comp(*__first2, *__first1))
            return false;
    }
    return false;
}

template <class _ExecutionPolicy, class _InputIterator1, class _InputIterator2, 
          class _Compare>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy,
                                                             bool>
lexicographical_compare(_ExecutionPolicy&& __exec, _InputIterator1 __first1, 
                        _InputIterator1 __last1, _InputIterator2 __first2, 
                        _InputIterator2 __last2, _Compare __comp)
{
    return __lexicographical_compare< __comp_ref_type<_Compare> >(__exec, __first1, __last1, __first2, __last2, __comp);
}

template <class _ExecutionPolicy, class _InputIterator1, class _InputIterator2>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy,
                                                             bool>
lexicographical_compare(_ExecutionPolicy&& __exec, _InputIterator1 __first1, 
                        _InputIterator1 __last1, _InputIterator2 __first2, 
                        _InputIterator2 __last2)
{
    return _VSTD::lexicographical_compare(__exec, __first1, __last1, __first2, 
                                          __last2,
                                         __less<typename iterator_traits<_InputIterator1>::value_type,
                                                typename iterator_traits<_InputIterator2>::value_type>());
}

// includes 

template <class _Compare, class _ExecutionPolicy, class _InputIterator1, 
          class _InputIterator2>
 constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy,
                                                             bool>
__includes(_ExecutionPolicy&& __exec, _InputIterator1 __first1, 
           _InputIterator1 __last1, _InputIterator2 __first2, 
           _InputIterator2 __last2, _Compare __comp)
{
    __BeginEndIteratorPair(__first2, __last2);

    for (; __first2 != __last2; ++__first1)
    {
        if (__first1 == __last1 || __comp(*__first2, *__first1))
            return false;
        if (!__comp(*__first1, *__first2))
            ++__first2;
    }
    return true;
}

template <class _ExecutionPolicy, class _InputIterator1, class _InputIterator2, 
          class _Compare>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy,
                                                             bool>
includes(_ExecutionPolicy&& __exec, _InputIterator1 __first1, 
         _InputIterator1 __last1, _InputIterator2 __first2, 
         _InputIterator2 __last2, _Compare __comp)
{
    return __includes< __comp_ref_type<_Compare> >(__exec, __first1, __last1, __first2, __last2, __comp);
}

template <class _ExecutionPolicy, class _InputIterator1, class _InputIterator2>
_LIBCPP_NODISCARD_EXT inline
_LIBCPP_INLINE_VISIBILITY  constexpr 
__cep::experimental::__internal::__enable_if_constexpr_par_execution_policy<
                                                             _ExecutionPolicy,
                                                             bool>
includes(_ExecutionPolicy&& __exec, _InputIterator1 __first1, 
         _InputIterator1 __last1, _InputIterator2 __first2, 
         _InputIterator2 __last2)
{
    return _VSTD::includes(__exec, __first1, __last1, __first2, __last2,
                          __less<typename iterator_traits<_InputIterator1>::value_type,
                                 typename iterator_traits<_InputIterator2>::value_type>());
}


_LIBCPP_END_NAMESPACE_STD

_LIBCPP_POP_MACROS

#endif  // _LIBCPP_ALGORITHM


